<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RoomChat ‚Äì Challenge (Clean)</title>
  <!-- Keine CSS-√Ñnderungen hier: wir nutzen bestehendes Layout/Optik deiner Seite -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

  <!--
    Wir greifen auf bestehende IDs zur√ºck.
    Erwartete Elemente im Layout (bereits vorhanden in deiner Seite / Optik bleibt):
      - Chatcontainer:  <div id="chat"></div>
      - Eingabe:        <input id="msg" type="text">
      - Senden-Button:  <button id="send">Senden</button>
    Optional (falls vorhanden, wird benutzt ‚Äì sonst ignoriert):
      - Punkteanzeige:  <span id="score">0</span>
      - Rankingtabelle: <tbody id="rankingBody"></tbody> (mit <div id="rankingTitle"></div> optional)
  -->

  <script>
  /* === Projekt (Supabase) === */
  const SUPABASE_URL  = "https://rombbbbnfngxwwhzmwjo.supabase.co";
  const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJvbWJiYmJuZm5neHd3aHptd2pvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxNjA4NTcsImV4cCI6MjA3NTczNjg1N30.HJTNIvcROzQn-nk2Z_CNNL3VL1zl96b8Zd8SglxU87I";
  const sb = window.supabase?.createClient(SUPABASE_URL, SUPABASE_ANON);
  </script>

  <script>
  /* === URL-Parameter: cls|room + nick === */
  (function ensureClsRoomCompat(){
    const P = new URLSearchParams(location.search);
    if (!P.get('cls') && P.get('room')) {
      const u = new URL(location.href);
      u.searchParams.set('cls', P.get('room'));
      history.replaceState(null, '', u.toString());
    }
  })();
  const P    = new URLSearchParams(location.search);
  const CLS  = P.get('cls') || 'default';
  const NICK = P.get('nick') || 'Gast';
  </script>

  <script>
  /* === Elemente (Layout bleibt, wir nehmen vorhandene IDs) === */
  const CHAT  = document.getElementById('chat');
  const INPUT = document.getElementById('msg');
  let   SEND  = document.getElementById('send');

  function addRow(text, who){
    // who: 'you' (Standard) oder 'bot'
    if (!CHAT) { console.log('[Chat]', who||'you', text); return; }
    const r = document.createElement('div'); r.className = 'row';
    const b = document.createElement('div'); b.className = who || 'you'; b.textContent = text;
    r.appendChild(b); CHAT.appendChild(r); CHAT.scrollTop = CHAT.scrollHeight;
    return r;
  }
  function addBotNote(t){ addRow(t, 'bot'); }
  </script>

  <script>
  /* === Wortlisten & Regeln (Moderation) === */
  // Basislisten (k√∂nnen bei Bedarf erg√§nzt werden)
  const BAD_RACIST  = (window.BAD_RACIST  || []).slice();
  const BAD_SEXIST  = (window.BAD_SEXIST  || []).slice();
  const HOMOPHOB    = (window.HOMOPHOB    || []).slice();
  const BAD_RUDE    = (window.BAD_RUDE    || []).slice();

  // Erg√§nzungen (inkl. 'fick dich', 'hure', 'lesbe', etc.)
  ["fick","ficken","fickt","fickst","fickte","gefickt","fick dich","fickdich"].forEach(w=>{ if(!BAD_RUDE.includes(w)) BAD_RUDE.push(w); });
  ["hure","hurensohn","fotze","bitch"].forEach(w=>{ if(!BAD_SEXIST.includes(w)) BAD_SEXIST.push(w); });
  ["lesbe","lesbisch","schwuchtel","homo"].forEach(w=>{ if(!HOMOPHOB.includes(w)) HOMOPHOB.push(w); });

  function hasAny(list, msg){
    const L = String(msg||'').toLowerCase();
    return (list||[]).some(w => {
      if (!w) return false;
      const s = String(w).toLowerCase();
      if (s === "fick dich") return /\bfick\s*dich\b/.test(L);
      return L.includes(s);
    });
  }

  function analyzeMessage(text){
    // Reihenfolge: negatives vor positives
    if (hasAny(BAD_RACIST.concat(BAD_SEXIST, HOMOPHOB), text)) {
      return { bad: true, delta: -2, category: "rassistisch/sexistisch", note: "‚ö†Ô∏è Rassistische/sexistische Sprache (‚àí2)." };
    }
    if (hasAny(BAD_RUDE, text)) {
      return { bad: true, delta: -1, category: "unh√∂flich", note: "‚ö†Ô∏è Unh√∂fliche Sprache (‚àí1)." };
    }
    const L = String(text||'').trim().toLowerCase();
    if (/^ich\b/.test(L)) {
      return { bad: false, delta: +2, category: "ich-form", note: "üëç Ich-Form (+2)." };
    }
    if (/\b(bitte|danke|k√∂nntest|k√∂nnten|w√ºrdest du|w√ºrdest|w√ºrde|entschuldigung|entschuldige)\b/.test(L)) {
      return { bad: false, delta: +1, category: "h√∂flich", note: "üôÇ H√∂fliche Form (+1)." };
    }
    return { bad: false, delta: 0, category: "neutral", note: "" };
  }
  </script>

  <script>
  /* === Punkte & Rangliste (nur wenn UI vorhanden ist) === */
  function updateMyScore(delta){
    if (!delta) return;
    const el = document.getElementById('score');
    if (el) {
      const cur = Number(el.textContent || 0);
      el.textContent = String(Math.max(0, cur + Number(delta||0)));
    }
  }
  async function upsertScore(nick, delta){
    if (!sb || !delta) return;
    try{
      const { data, error } = await sb.from('scores').select('score').eq('cls', CLS).eq('nick', nick).single();
      let cur = (!error && data && typeof data.score==='number') ? data.score : 0;
      const next = Math.max(0, cur + delta);
      await sb.from('scores').upsert({ cls: CLS, nick, score: next }).select();
    }catch(e){ console.warn('[scores upsert]', e); }
  }
  async function loadScores(){
    try{
      const tbody = document.getElementById('rankingBody'); if (!tbody) return;
      const { data, error } = await sb.from('scores').select('nick,score').eq('cls', CLS);
      if (error) { console.warn('[scores load]', error); return; }
      const rows = (data||[]).map(r => ({name:r.nick, score:r.score||0}))
        .sort((a,b)=> b.score - a.score || a.name.localeCompare(b.name));
      tbody.innerHTML = "";
      rows.forEach((r,i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${r.name}</td><td><strong>${r.score}</strong></td>`;
        tbody.appendChild(tr);
      });
      const title = document.getElementById('rankingTitle'); if (title) title.textContent = `Rangliste (${CLS})`;
    }catch(e){ console.warn(e); }
  }
  function subscribeScores(){
    if (!sb) return;
    try{
      sb.channel('rank:'+CLS)
        .on('postgres_changes', { event:'*', schema:'public', table:'scores', filter: 'cls=eq.'+CLS }, _ => loadScores())
        .subscribe();
    }catch(e){ console.warn('[scores subscribe]', e); }
  }
  </script>

  <script>
  /* === Chat: Verlauf, Realtime, Senden mit Moderation & Punkte === */
  const seen = new Set();
  let lastTs = null;

  function renderMsg(row){
    if (!row) return;
    const id = row.id || (row.nick+row.body+row.ts);
    if (seen.has(id)) return;
    seen.add(id);
    addRow(`${row.nick}: ${row.body}`, 'you');
    if (!lastTs || row.ts > lastTs) lastTs = row.ts;
  }

  async function loadHistory(){
    if (!sb) return;
    try{
      const { data, error } = await sb.from('messages').select('id,cls,nick,body,ts').eq('cls', CLS).order('ts', { ascending:true }).limit(200);
      if (error) { console.warn('[history]', error); return; }
      (data||[]).forEach(renderMsg);
    }catch(e){ console.warn(e); }
  }

  function subscribeMessages(){
    if (!sb) return;
    try{
      sb.channel('room:'+CLS)
        .on('postgres_changes', { event:'INSERT', schema:'public', table:'messages', filter: 'cls=eq.'+CLS }, payload => renderMsg(payload.new))
        .subscribe();
    }catch(e){ console.warn('[realtime]', e); }
  }

  // Polling-Fallback (falls Realtime aus ist)
  setInterval(async function(){
    if (!sb) return;
    try{
      const { data, error } = await sb.from('messages').select('id,cls,nick,body,ts')
        .eq('cls', CLS).gt('ts', lastTs || '1970-01-01').order('ts', { ascending:true }).limit(200);
      if (!error) (data||[]).forEach(renderMsg);
    }catch(e){}
  }, 2000);

  async function doSend(){
    if (!INPUT) return;
    const text = (INPUT.value||'').trim(); if (!text) return;

    const res = analyzeMessage(text);
    if (res.bad){
      // Nachricht nicht speichern, nur monieren & Minuspunkte
      addRow('‚õî Nachricht verborgen (unangemessene Sprache)', 'you');
      addBotNote(res.note || '‚ö†Ô∏è Bitte respektvoll formulieren.');
      updateMyScore(res.delta); upsertScore(NICK, res.delta);
      INPUT.value = ""; INPUT.focus();
      return;
    }

    // Gute Nachricht: lokal zeigen, speichern, Punkte vergeben
    const local = { id: 'local-'+Date.now(), cls: CLS, nick: NICK, body: text, ts: new Date().toISOString() };
    renderMsg(local);
    try{
      const { data, error } = await sb.from('messages').insert([{ cls: CLS, nick: NICK, body: text }]).select('id,ts').single();
      if (!error && data){ local.id = data.id; local.ts = data.ts; }
    }catch(e){ console.warn('[insert]', e); addBotNote('‚ö†Ô∏è Senden fehlgeschlagen (siehe Console).'); }

    updateMyScore(res.delta); upsertScore(NICK, res.delta);
    INPUT.value = ""; INPUT.focus();
  }

  // Events sicher binden, ohne anderes JS zu st√∂ren
  (function bindEvents(){
    if (!SEND || !INPUT) return;
    try{ const clone = SEND.cloneNode(true); SEND.parentNode.replaceChild(clone, SEND); SEND = clone; }catch(e){}
    SEND.addEventListener('click', doSend);
    INPUT.addEventListener('keydown', e => { if (e.key === 'Enter') doSend(); });
  })();

  // Init
  loadHistory();
  subscribeMessages();
  loadScores();
  subscribeScores();

  console.log('[RoomChat] ready', { CLS, NICK });
  </script>

</body>
</html>
